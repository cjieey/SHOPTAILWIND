"use strict";Object.defineProperty(exports, "__esModule", {value: true});/* eslint max-len: 0 */










var _index = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _types = require('../tokenizer/types');
var _base = require('../traverser/base');













var _expression = require('../traverser/expression');








var _statement = require('../traverser/statement');









var _util = require('../traverser/util');

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== _keywords.ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, tok || _types.TokenType.colon);
  flowParseType();
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParsePredicate() {
  _util.expect.call(void 0, _types.TokenType.modulo);
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._checks);
  if (_index.eat.call(void 0, _types.TokenType.parenL)) {
    _expression.parseExpression.call(void 0, );
    _util.expect.call(void 0, _types.TokenType.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.colon);
  if (_index.match.call(void 0, _types.TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.modulo)) {
      flowParsePredicate();
    }
  }
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParseDeclareClass() {
  _index.next.call(void 0, );
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  _index.next.call(void 0, );
  _expression.parseIdentifier.call(void 0, );

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  _util.expect.call(void 0, _types.TokenType.parenL);
  flowParseFunctionTypeParams();
  _util.expect.call(void 0, _types.TokenType.parenR);

  flowParseTypeAndPredicateInitialiser();

  _util.semicolon.call(void 0, );
}

function flowParseDeclare() {
  if (_index.match.call(void 0, _types.TokenType._class)) {
    flowParseDeclareClass();
  } else if (_index.match.call(void 0, _types.TokenType._function)) {
    flowParseDeclareFunction();
  } else if (_index.match.call(void 0, _types.TokenType._var)) {
    flowParseDeclareVariable();
  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._module)) {
    if (_index.eat.call(void 0, _types.TokenType.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (_index.match.call(void 0, _types.TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    _util.unexpected.call(void 0, );
  }
}

function flowParseDeclareVariable() {
  _index.next.call(void 0, );
  flowParseTypeAnnotatableIdentifier();
  _util.semicolon.call(void 0, );
}

function flowParseDeclareModule() {
  if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    _expression.parseIdentifier.call(void 0, );
  }

  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.match.call(void 0, _types.TokenType._import)) {
      _index.next.call(void 0, );
      _statement.parseImport.call(void 0, );
    } else {
      _util.unexpected.call(void 0, );
    }
  }
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function flowParseDeclareExportDeclaration() {
  _util.expect.call(void 0, _types.TokenType._export);

  if (_index.eat.call(void 0, _types.TokenType._default)) {
    if (_index.match.call(void 0, _types.TokenType._function) || _index.match.call(void 0, _types.TokenType._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      _util.semicolon.call(void 0, );
    }
  } else if (
    _index.match.call(void 0, _types.TokenType._var) || // declare export var ...
    _index.match.call(void 0, _types.TokenType._function) || // declare export function ...
    _index.match.call(void 0, _types.TokenType._class) || // declare export class ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    _index.match.call(void 0, _types.TokenType.star) || // declare export * from ''
    _index.match.call(void 0, _types.TokenType.braceL) || // declare export {} ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) || // declare export interface ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) || // declare export type ...
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    _statement.parseExport.call(void 0, );
  } else {
    _util.unexpected.call(void 0, );
  }
}

function flowParseDeclareModuleExports() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._exports);
  flowParseTypeAnnotation();
  _util.semicolon.call(void 0, );
}

function flowParseDeclareTypeAlias() {
  _index.next.call(void 0, );
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  _index.next.call(void 0, );
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  _index.next.call(void 0, );
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && _index.eat.call(void 0, _types.TokenType.comma));
  }

  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._mixins)) {
    _index.next.call(void 0, );
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }

  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
    _index.next.call(void 0, );
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  _expression.parseIdentifier.call(void 0, );
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(_types.TokenType.eq);
  _util.semicolon.call(void 0, );
}

function flowParseOpaqueType(declare) {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeInitialiser(_types.TokenType.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(_types.TokenType.eq);
  }
  _util.semicolon.call(void 0, );
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    flowParseType();
  }
}

 function flowParseTypeParameterDeclaration() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {
    _index.next.call(void 0, );
  } else {
    _util.unexpected.call(void 0, );
  }

  do {
    flowParseTypeParameter();
    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  } while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error);
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
} exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;

function flowParseTypeParameterInstantiation() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.lessThan);
  while (!_index.match.call(void 0, _types.TokenType.greaterThan) && !_base.state.error) {
    flowParseType();
    if (!_index.match.call(void 0, _types.TokenType.greaterThan)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
}

function flowParseInterfaceType() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._interface);
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (_index.eat.call(void 0, _types.TokenType.comma));
  }
  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if (_index.match.call(void 0, _types.TokenType.num) || _index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    _expression.parseIdentifier.call(void 0, );
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (_index.lookaheadType.call(void 0, ) === _types.TokenType.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  _util.expect.call(void 0, _types.TokenType.bracketR);
  _util.expect.call(void 0, _types.TokenType.bracketR);
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    _index.eat.call(void 0, _types.TokenType.question);
    flowParseTypeInitialiser();
  }
}

function flowParseObjectTypeMethodish() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  _util.expect.call(void 0, _types.TokenType.parenL);
  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();
    if (!_index.match.call(void 0, _types.TokenType.parenR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }

  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  _util.expect.call(void 0, _types.TokenType.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && _index.match.call(void 0, _types.TokenType.braceBarL)) {
    _util.expect.call(void 0, _types.TokenType.braceBarL);
    endDelim = _types.TokenType.braceBarR;
  } else {
    _util.expect.call(void 0, _types.TokenType.braceL);
    endDelim = _types.TokenType.braceR;
  }

  while (!_index.match.call(void 0, endDelim) && !_base.state.error) {
    if (allowProto && _util.isContextual.call(void 0, _keywords.ContextualKeyword._proto)) {
      const lookahead = _index.lookaheadType.call(void 0, );
      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        _index.next.call(void 0, );
        allowStatic = false;
      }
    }
    if (allowStatic && _util.isContextual.call(void 0, _keywords.ContextualKeyword._static)) {
      const lookahead = _index.lookaheadType.call(void 0, );
      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        _index.next.call(void 0, );
      }
    }

    flowParseVariance();

    if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
      if (_index.eat.call(void 0, _types.TokenType.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._get) || _util.isContextual.call(void 0, _keywords.ContextualKeyword._set)) {
        const lookahead = _index.lookaheadType.call(void 0, );
        if (lookahead === _types.TokenType.name || lookahead === _types.TokenType.string || lookahead === _types.TokenType.num) {
          _index.next.call(void 0, );
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  _util.expect.call(void 0, endDelim);
}

function flowParseObjectTypeProperty() {
  if (_index.match.call(void 0, _types.TokenType.ellipsis)) {
    _util.expect.call(void 0, _types.TokenType.ellipsis);
    if (!_index.eat.call(void 0, _types.TokenType.comma)) {
      _index.eat.call(void 0, _types.TokenType.semi);
    }
    // Explicit inexact object syntax.
    if (_index.match.call(void 0, _types.TokenType.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      _index.eat.call(void 0, _types.TokenType.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!_index.eat.call(void 0, _types.TokenType.semi) && !_index.eat.call(void 0, _types.TokenType.comma) && !_index.match.call(void 0, _types.TokenType.braceR) && !_index.match.call(void 0, _types.TokenType.braceBarR)) {
    _util.unexpected.call(void 0, );
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    _expression.parseIdentifier.call(void 0, );
  }
  while (_index.eat.call(void 0, _types.TokenType.dot)) {
    _expression.parseIdentifier.call(void 0, );
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  _util.expect.call(void 0, _types.TokenType._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  _util.expect.call(void 0, _types.TokenType.bracketL);
  // We allow trailing commas
  while (_base.state.pos < _base.input.length && !_index.match.call(void 0, _types.TokenType.bracketR)) {
    flowParseType();
    if (_index.match.call(void 0, _types.TokenType.bracketR)) {
      break;
    }
    _util.expect.call(void 0, _types.TokenType.comma);
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
}

function flowParseFunctionTypeParam() {
  const lookahead = _index.lookaheadType.call(void 0, );
  if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {
    _expression.parseIdentifier.call(void 0, );
    _index.eat.call(void 0, _types.TokenType.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();
    if (!_index.match.call(void 0, _types.TokenType.parenR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = _base.state.noAnonFunctionType;

  switch (_base.state.type) {
    case _types.TokenType.name: {
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      _expression.parseIdentifier.call(void 0, );
      flowParseGenericType();
      return;
    }

    case _types.TokenType.braceL:
      flowParseObjectType(false, false, false);
      return;

    case _types.TokenType.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case _types.TokenType.bracketL:
      flowParseTupleType();
      return;

    case _types.TokenType.lessThan:
      flowParseTypeParameterDeclaration();
      _util.expect.call(void 0, _types.TokenType.parenL);
      flowParseFunctionTypeParams();
      _util.expect.call(void 0, _types.TokenType.parenR);
      _util.expect.call(void 0, _types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.parenL:
      _index.next.call(void 0, );

      // Check to see if this is actually a grouped type
      if (!_index.match.call(void 0, _types.TokenType.parenR) && !_index.match.call(void 0, _types.TokenType.ellipsis)) {
        if (_index.match.call(void 0, _types.TokenType.name)) {
          const token = _index.lookaheadType.call(void 0, );
          isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        _base.state.noAnonFunctionType = false;
        flowParseType();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          _base.state.noAnonFunctionType ||
          !(_index.match.call(void 0, _types.TokenType.comma) || (_index.match.call(void 0, _types.TokenType.parenR) && _index.lookaheadType.call(void 0, ) === _types.TokenType.arrow))
        ) {
          _util.expect.call(void 0, _types.TokenType.parenR);
          return;
        } else {
          // Eat a comma if there is one
          _index.eat.call(void 0, _types.TokenType.comma);
        }
      }

      flowParseFunctionTypeParams();

      _util.expect.call(void 0, _types.TokenType.parenR);
      _util.expect.call(void 0, _types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.minus:
      _index.next.call(void 0, );
      _expression.parseLiteral.call(void 0, );
      return;

    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType._true:
    case _types.TokenType._false:
    case _types.TokenType._null:
    case _types.TokenType._this:
    case _types.TokenType._void:
    case _types.TokenType.star:
      _index.next.call(void 0, );
      return;

    default:
      if (_base.state.type === _types.TokenType._typeof) {
        flowParseTypeofType();
        return;
      } else if (_base.state.type & _types.TokenType.IS_KEYWORD) {
        _index.next.call(void 0, );
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
        return;
      }
  }

  _util.unexpected.call(void 0, );
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!_util.canInsertSemicolon.call(void 0, ) && (_index.match.call(void 0, _types.TokenType.bracketL) || _index.match.call(void 0, _types.TokenType.questionDot))) {
    _index.eat.call(void 0, _types.TokenType.questionDot);
    _util.expect.call(void 0, _types.TokenType.bracketL);
    if (_index.eat.call(void 0, _types.TokenType.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      _util.expect.call(void 0, _types.TokenType.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if (_index.eat.call(void 0, _types.TokenType.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!_base.state.noAnonFunctionType && _index.eat.call(void 0, _types.TokenType.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  _index.eat.call(void 0, _types.TokenType.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  _index.eat.call(void 0, _types.TokenType.bitwiseOR);
  flowParseIntersectionType();
  while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

 function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
} exports.flowParseTypeAnnotation = flowParseTypeAnnotation;

function flowParseTypeAnnotatableIdentifier() {
  _expression.parseIdentifier.call(void 0, );
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}

 function flowParseVariance() {
  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
    _index.next.call(void 0, );
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
  }
} exports.flowParseVariance = flowParseVariance;

// ==================================
// Overrides
// ==================================

 function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  _expression.parseFunctionBody.call(void 0, false, funcContextId);
} exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;

 function flowParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (_index.match.call(void 0, _types.TokenType.questionDot) && _index.lookaheadType.call(void 0, ) === _types.TokenType.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }
    _index.next.call(void 0, );
    flowParseTypeParameterInstantiation();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0, );
    return;
  } else if (!noCalls && _index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    flowParseTypeParameterInstantiation();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0, );
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }
  _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
} exports.flowParseSubscript = flowParseSubscript;

 function flowStartParseNewArguments() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    const snapshot = _base.state.snapshot();
    flowParseTypeParameterInstantiation();
    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
} exports.flowStartParseNewArguments = flowStartParseNewArguments;

// interfaces
 function flowTryParseStatement() {
  if (_index.match.call(void 0, _types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._interface) {
    const oldIsType = _index.pushTypeContext.call(void 0, 0);
    _index.next.call(void 0, );
    flowParseInterface();
    _index.popTypeContext.call(void 0, oldIsType);
    return true;
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
} exports.flowTryParseStatement = flowTryParseStatement;

 function flowTryParseExportDefaultExpression() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
} exports.flowTryParseExportDefaultExpression = flowTryParseExportDefaultExpression;

// declares, interfaces and type aliases
 function flowParseIdentifierStatement(contextualKeyword) {
  if (contextualKeyword === _keywords.ContextualKeyword._declare) {
    if (
      _index.match.call(void 0, _types.TokenType._class) ||
      _index.match.call(void 0, _types.TokenType.name) ||
      _index.match.call(void 0, _types.TokenType._function) ||
      _index.match.call(void 0, _types.TokenType._var) ||
      _index.match.call(void 0, _types.TokenType._export)
    ) {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      flowParseDeclare();
      _index.popTypeContext.call(void 0, oldIsType);
    }
  } else if (_index.match.call(void 0, _types.TokenType.name)) {
    if (contextualKeyword === _keywords.ContextualKeyword._interface) {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      flowParseInterface();
      _index.popTypeContext.call(void 0, oldIsType);
    } else if (contextualKeyword === _keywords.ContextualKeyword._type) {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      flowParseTypeAlias();
      _index.popTypeContext.call(void 0, oldIsType);
    } else if (contextualKeyword === _keywords.ContextualKeyword._opaque) {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      flowParseOpaqueType(false);
      _index.popTypeContext.call(void 0, oldIsType);
    }
  }
  _util.semicolon.call(void 0, );
} exports.flowParseIdentifierStatement = flowParseIdentifierStatement;

// export type
 function flowShouldParseExportDeclaration() {
  return (
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._type) ||
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._interface) ||
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque) ||
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._enum)
  );
} exports.flowShouldParseExportDeclaration = flowShouldParseExportDeclaration;

 function flowShouldDisallowExportDefaultSpecifier() {
  return (
    _index.match.call(void 0, _types.TokenType.name) &&
    (_base.state.contextualKeyword === _keywords.ContextualKeyword._type ||
      _base.state.contextualKeyword === _keywords.ContextualKeyword._interface ||
      _base.state.contextualKeyword === _keywords.ContextualKeyword._opaque ||
      _base.state.contextualKeyword === _keywords.ContextualKeyword._enum)
  );
} exports.flowShouldDisallowExportDefaultSpecifier = flowShouldDisallowExportDefaultSpecifier;

 function flowParseExportDeclaration() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    _index.next.call(void 0, );

    if (_index.match.call(void 0, _types.TokenType.braceL)) {
      // export type { foo, bar };
      _statement.parseExportSpecifiers.call(void 0, );
      _statement.parseExportFrom.call(void 0, );
    } else {
      // export type Foo = Bar;
      flowParseTypeAlias();
    }
    _index.popTypeContext.call(void 0, oldIsType);
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._opaque)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    _index.next.call(void 0, );
    // export opaque type Foo = Bar;
    flowParseOpaqueType(false);
    _index.popTypeContext.call(void 0, oldIsType);
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    _index.next.call(void 0, );
    flowParseInterface();
    _index.popTypeContext.call(void 0, oldIsType);
  } else {
    _statement.parseStap      ‰     ø      °àP    påäÂ;OÚ  €            . < H D C L O N E . E X E - A C 8 5 7 E 4 0 . p f       p      .ë   6 ø     p°àP    påäÂ;OÚ               . < H D C L O N E . E X E - C 7 1 7 F D 3 D . p f       p      .ë   6 ø     à°àP    påäÂ;OÚ  €            . < H D C L O N E . E X E - C 7 1 7 F D 3 D . p f       p      Ã0    ø     P±àP    påäÂ;OÚ               4 < H X A C C O U N T S . E X E - 9 9 F E E B D E . p f p      Ã0    ø     À±àP    ëGçÂ;OÚ  €            4 < H X A C C O U N T S . E X E - 9 9 F E E B D E . p f p      ¶+    ø     0²àP    ëGçÂ;OÚ               2 < H X O U T L O O K . E X E - 7 7 B 7 9 8 7 1 . p f   p      ¶+    ø      ²àP    ëGçÂ;OÚ  €            2 < H X O U T L O O K . E X E - 7 7 B 7 9 8 7 1 . p f   p      v˜    ø     ³àP    ëGçÂ;OÚ               0 < I E X P L O R E . E X E - 0 5 8 F E 8 F 5 . p f     p      v˜    ø     €³àP    ëGçÂ;OÚ  €            0 < I E X P L O R E . E X E - 0 5 8 F E 8 F 5 . p f           "+    ø     ð³àP    ëGçÂ;OÚ               R < I N S T A L L _ F L A S H _ P L A Y E R _ 1 1 _ P L U G I - 2 1 E 0 E D 9 B . p f         "+    ø     €´àP    ëGçÂ;OÚ  €            R < I N S T A L L _ F L A S H _ P L A Y E R _ 1 1 _ P L U G I - 2 1 E 0 E D 9 B . p f   p      š–    ø     µàP    ëGçÂ;OÚ               0 < I S - L S B S S . T M P - 3 3 F B 5 C 1 E . p f     p      š–    ø     €µàP    ëGçÂ;OÚ  €            0 < I S - L S B S S . T M P - 3 3 F B 5 C 1 E . p f     h      
    ø     ðµàP    ëGçÂ;OÚ               , < K E Y G E N . E X E - 5 1 8 4 4 B E 7 . p f h      
    ø     X¶àP    ëGçÂ;OÚ  €            , < K E Y G E N . E X E - 5 1 8 4 4 B E 7 . p f x      )    ø     À¶àP    ëGçÂ;OÚ               6 < K M S A U T O   N E T . E X E - 4 E 9 9 7 A A 2 . p f       x      )    ø     8·àP    ëGçÂ;OÚ  €            6 < K M S A U T O   N E T . E X E - 4 E 9 9 7 A A 2 . p f       p      çv    
 ø     °·àP    ëGçÂ;OÚ               . < K M S E L D I . E X E - 3 4 7 C D 4 0 D . p f       p      çv    
 ø      ¸àP    ëGçÂ;OÚ  €            . < K M S E L D I . E X E - 3 4 7 C D 4 0 D . p f       P      É     ø     ¸àP    ëGçÂ;OÚ                < L a y o u t . i n i P      É     ø     à¸àP    ëGçÂ;OÚ  €             < L a y o u t . i n i p      Æ     ø     0¹àP    ëGçÂ;OÚ               . < L O C K A P P . E X E - A C D 6 9 F 0 7 . p f       p      Æ     ø      ¹àP    ëGçÂ;OÚ  €            . < L O C K A P P . E X E - A C D 6 9 F 0 7 . p f       p      U‘    ø     ºàP    ëGçÂ;OÚ               . < L O G O N U I . E X E - F 6 3 9 B D 7 E . p f       p      U‘    ø     €ºàP    ëGçÂ;OÚ  €            . < L O G O N U I . E X E - F 6 3 9 B D 7 E . p f       ˆ      Å    ø     ðºàP    ëGçÂ;OÚ               F < M I C R O S O F T E D G E U P D A T E . E X E - 7 A 5 9 5 3 2 6 . p f             ,é        x»àP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        ¼àP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        ˜¼àP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        (½àP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        ¸½àP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        H¾àP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        Ø¾àP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        h¿àP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g                 ,é         ÀàP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g   ˆ      Å    ø     ÀàP    ëGçÂ;OÚ  €            F < M I C R O S O F T E D G E U P D A T E . E X E - 7 A 5 9 5 3 2 6 . p f             ,é        ÁàP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         žþ     ø     ¨ÁàP    ëGçÂ;OÚ               R < M I C R O S O F T E D G E _ X 6 4 _ 1 1 9 . 0 . 2 1 5 1 . - D 2 9 2 B 5 8 1 . p f         ,é        8ÂàP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        ÈÂàP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         žþ     ø     XÃàP    ëGçÂ;OÚ  €            R < M I C R O S O F T E D G E _ X 6 4 _ 1 1 9 . 0 . 2 1 5 1 . - D 2 9 2 B 5 8 1 . p f   h      x‘    ø     èÃàP    ëGçÂ;OÚ               & < M M C . E X E - B 7 2 D A 5 9 F . p f       h      x‘    ø     PÄàP    ëGçÂ;OÚ  €            & < M M C . E X E - B 7 2 D A 5 9 F . p f       €      xª     ø     ¸ÄàP    ëGçÂ;OÚ               > < M O U S O C O R E W O R K E R . E X E - 4 4 2 9 A C 2 B . p f       €      xª     ø     8ÅàP    ëGçÂ;OÚ  €            > < M O U S O C O R E W O R K E R . E X E - 4 4 2 9 A C 2 B . p f       p      Ñ     ø     ¸ÅàP    ëGçÂ;OÚ               0 < M P C M D R U N . E X E - A 1 4 B 7 1 7 8 . p f     p      Ñ     ø     (ÆàP    ëGçÂ;OÚ  €            0 < M P C M D R U N . E X E - A 1 4 B 7 1 7 8 . p f     p      3	   
 ø     ˜ÆàP    ëGçÂ;OÚ               2 < M P S I G S T U B . E X E - 5 D 0 4 5 0 B 3 . p f   p      3	   
 ø     ÇàP    ëGçÂ;OÚ  €            2 < M P S I G S T U B . E X E - 5 D 0 4 5 0 B 3 . p f   p      ñ    ø     xÇàP    ëGçÂ;OÚ               0 < M S C O R S V W . E X E - 8 C E 1 A 3 2 2 . p f           ,é        èÇàP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        xÈàP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        ÉàP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        ˜ÉàP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g   p      ñ    ø     (ÊàP    ëGçÂ;OÚ  €            0 < M S C O R S V W . E X E - 8 C E 1 A 3 2 2 . p f           ,é        ˜ÊàP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        (ËàP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g   h      Õó    
 ø     ¸ËàP    ëGçÂ;OÚ               ( < M S D T . E X E - D 5 7 9 9 5 7 D . p f           ,é         ÌàP    ëGçÂ;OÚ               R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g         ,é        °ÌàP    ëGçÂ;OÚ  €            R < R - g p u - 0 - g 6 - c 2 0 0 - 2 0 2 4 - 1 - 2 5 - 1 1 - 8 - 2 5 - 1 0 4 . l o g   h      Õó    
 ø     @ÍàP    /ªéÂ;OÚ  €            ( < M S D T . E X E - D 5 7 9 9 5 7 D . p f     h      »•    ø     ¨ÍàP    /ªéÂ;OÚ               , < M S E D G E . E X E - 3 7 D 2 5 F 9 A . p f h      »•    ø     ÎàP    /ªéÂ;OÚ  €            , < M S E D G E . E X E - 3 7 D 2 5 F 9 A . p f h      0    ø     xÎàP    /ªéÂ;OÚ               , < M S E D G E . E X E - 3 7 D 2 5 F A 1 . p f h      0    ø     àÎàP    /ªéÂ;OÚ  €            , < M S E D G E . E X E - 3 7 D 2 5 F A 1 . p f p      ™¨     ø     HÏàP    /ªéÂ;OÚ               . < M S I E X E C . E X E - 8 F F B 1 6 3 3 . p f                                                                               ase.state.restoreFromSnapshot(snapshot);
  }

  _expression.baseParseSubscripts.call(void 0, startTokenIndex, noCalls);
} exports.flowParseSubscripts = flowParseSubscripts;

// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters() {
  _base.state.scopeDepth++;
  const startTokenIndex = _base.state.tokens.length;
  _statement.parseFunctionParams.call(void 0, );
  if (!_expression.parseArrow.call(void 0, )) {
    return false;
  }
  _expression.parseArrowExpression.call(void 0, startTokenIndex);
  return true;
}

function flowParseEnumDeclaration() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
  _expression.parseIdentifier.call(void 0, );
  flowParseEnumBody();
}

function flowParseEnumBody() {
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._of)) {
    _index.next.call(void 0, );
  }
  _util.expect.call(void 0, _types.TokenType.braceL);
  flowParseEnumMembers();
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function flowParseEnumMembers() {
  while (!_index.match.call(void 0, _types.TokenType.braceR) && !_base.state.error) {
    if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
      break;
    }
    flowParseEnumMember();
    if (!_index.match.call(void 0, _types.TokenType.braceR)) {
      _util.expect.call(void 0, _types.TokenType.comma);
    }
  }
}

function flowParseEnumMember() {
  _expression.parseIdentifier.call(void 0, );
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    // Flow enum values are always just one token (a string, number, or boolean literal).
    _index.next.call(void 0, );
  }
}
